    case MSG_ACCESS_VIOLATN:  p = "Violation accès mémoire";                                                     break;
    case MSG_ADD_BAD_TYPE:    p = "Ajout d'une valeur de type %s non conforme dans un tableau %s";               break;
    case MSG_ALLOC_ERROR:     p = "Erreur d'allocation de %s";                                                   break;
    case MSG_ANSWER_TYPE:     p = "Réponse de type";                                                             break;
    case MSG_API_CONF_ERROR:  p = "Erreur SQL: API_CONFORMANCE";                                                 break;
    case MSG_APPL_NOT_INIT:   p = "Application non initialisée";                                                 break;
    case MSG_ARRAY_BNDS_EXCD: p = "Hors limite de tableau";                                                      break;
    case MSG_BAD_ARRAY_OPER:  p = "Les tableaux doivent utiliser l'opérateur IN";                                break;
    case MSG_BAD_ARRAY_TYPE:  p = "Type=%d invalide pour un tableau";                                            break;
    case MSG_BAD_ARRAY_VAL:   p = "Les tableaux doivent avoir le même nombre de valeurs";                        break;
    case MSG_BAD_BIN_FMT:     p = "Format invalide %c pour la colonne BIN %s";                                   break;
    case MSG_BAD_BLK_ESTIM:   p = "Nombre de blocs supérieur à l'estimation";                                    break;
    case MSG_BAD_BLK_SIZE:    p = "Taille du bloc %d non conforme";                                              break;
    case MSG_BAD_BYTE_NUM:    p = "Le nombre d'octets écrits est faux";                                          break;
    case MSG_BAD_BYTE_READ:   p = "Le nombre d'octets lus est faux";                                             break;
    case MSG_BAD_COL_TYPE:    p = "Type invalide %s pour la colonne %s";                                         break;
    case MSG_BAD_COL_XPATH:   p = "Xpath invalide colonne %s de la table HTML %s";                               break;
    case MSG_BAD_CONST_TYPE:  p = "Type=%d invalide pour une constante";                                         break;
    case MSG_BAD_CONV_TYPE:   p = "Convertion de type invalide %d";                                              break;
    case MSG_BAD_DATETIME:    p = "Valeur date/temps invalide";                                                  break;
    case MSG_BAD_DBF_FILE:    p = "Le fichier DBF %s est altéré";                                                break;
    case MSG_BAD_DBF_REC:     p = "Fichier DBF %s altéré enregistrement %d";                                     break;
    case MSG_BAD_DBF_TYPE:    p = "Type DBF %c non supporté colonne %s";                                         break;
    case MSG_BAD_DIRECTORY:   p = "Répertoire invalide %s: %s";                                                  break;
    case MSG_BAD_FIELD_RANK:  p = "Rang %d invalide pour la colonne %s";                                         break;
    case MSG_BAD_FIELD_TYPE:  p = "Mauvais type de champ %s";                                                    break;
    case MSG_BAD_FILE_HANDLE: p = "Handle de fichier invalide: %s";                                              break;
    case MSG_BAD_FILTER:      p = "Mauvais filtre: Opc=%d B_T=%d %d Type=%d %d";                                 break;
    case MSG_BAD_FILTER_CONV: p = "Conversion filtre incorrecte, B_T=%d,%d";                                     break;
    case MSG_BAD_FILTER_OP:   p = "Opérateur de filtre invalide %d";                                             break;
    case MSG_BAD_FLD_FORMAT:  p = "Format invalide pour le champs %d de %s";                                     break;
    case MSG_BAD_FLD_LENGTH:  p = "Champs %s trop long (%s --> %d) ligne %d de %s";                              break;
    case MSG_BAD_FREQ_SET:    p = "Spécification erronnée de Freq pour la colonne %s";                           break;
    case MSG_BAD_FUNC_MODE:   p = "%s: mode invalide %d";                                                        break;
    case MSG_BAD_HANDLE_VAL:  p = "Valeur Handle invalide";                                                      break;
    case MSG_BAD_HEADER:      p = "Fichier %s: bloc en-tête altéré";                                             break;
    case MSG_BAD_HEAD_END:    p = "Lecture fin d'en-tête impossible";                                            break;
    case MSG_BAD_INDEX_FILE:  p = "Fichier index %s corrompu";                                                   break;
    case MSG_BAD_LINEFLD_FMT: p = "Format invalide ligne %d champs %d de %s";                                    break;
    case MSG_BAD_LINE_LEN:    p = "Longueur ligne non égale à Lrecl";                                            break;
    case MSG_BAD_LRECL:       p = "Disparité lrecl table/fichier (%d,%hd)";                                      break;
    case MSG_BAD_NODE_TYPE:   p = "Type noeud erroné pour la table";                                             break;
    case MSG_BAD_OFFSET_VAL:  p = "Nul offset invalide pour une table CSV";                                      break;
    case MSG_BAD_OPEN_MODE:   p = "Mode d'ouverture invalide %d";                                                break;
    case MSG_BAD_PARAM_TYPE:  p = "%.8s: Paramètre de type=%d invalide";                                         break;
    case MSG_BAD_PARM_COUNT:  p = "Nombre de paramètres incohérent";                                             break;
    case MSG_BAD_QUOTE_FIELD: p = "Quote manquante dans %s champs %d ligne %d";                                  break;
    case MSG_BAD_READ_NUMBER: p = "Mauvais nombre %d de valeurs lues dans %s";                                   break;
    case MSG_BAD_RECFM:       p = "Recfm type %d invalide pour DOSCOL";                                          break;
    case MSG_BAD_RECFM_VAL:   p = "Valeur invalide %d de Recfm";                                                 break;
    case MSG_BAD_SET_CASE:    p = "La casse d'un tableau ne peut pas passer de non respect à respecter";         break;
    case MSG_BAD_SET_STRING:  p = "SetValue: appel invalide pour STRING";                                        break;
    case MSG_BAD_SPECIAL_COL: p = "Colonne spéciale invalide %s";                                                break;
    case MSG_BAD_SPEC_COLUMN: p = "Colonne spéciale invalide pour ce type de table";                             break;
    case MSG_BAD_TABLE_TYPE:  p = "Type invalide %s pour la table %s";                                           break;
    case MSG_BAD_TYPE_LIKE:   p = "Type(%d)= %d invalide pour LIKE";                                             break;
    case MSG_BAD_VALBLK_INDX: p = "Valeur hors limites de l'index du bloc de valeurs";                           break;
    case MSG_BAD_VALBLK_TYPE: p = "Type=%d invalide pour un bloc de valeurs";                                    break;
    case MSG_BAD_VALNODE:     p = "Type %d invalide pour le noeud valeur colonne %s";                            break;
    case MSG_BAD_VALUE_TYPE:  p = "Type de valeur invalide %d";                                                  break;
    case MSG_BAD_VAL_UPDATE:  p = "Impossible de déterminer quelle valeur %s doit être mise à jour";             break;
    case MSG_BAS_NS_LIST:     p = "Format invalide de la liste des espace-noms";                                 break;
    case MSG_BIN_F_TOO_LONG:  p = "Valeur trop longue pour le champ %s (%d --> %d)";                             break;
    case MSG_BIN_MODE_FAIL:   p = "Echec mode binaire: %s";                                                      break;
    case MSG_BLKTYPLEN_MISM:  p = "Disparité types/longueurs de bloc dans SetValue";                             break;
    case MSG_BLK_IS_NULL:     p = "Blk est nul";                                                                 break;
    case MSG_BREAKPOINT:      p = "Point de contrôle";                                                           break;
    case MSG_BUILD_INDEX:     p = "Construction index %s sur %s";                                                break;
    case MSG_CANNOT_OPEN:     p = "Ouverture impossible de %s";                                                  break;
    case MSG_CHSIZE_ERROR:    p = "Erreur dans chsize: %s";                                                      break;
    case MSG_COL_ALLOC_ERR:   p = "Allocation impossible du noeud colonne";                                      break;
    case MSG_COL_ISNOT_TABLE: p = "La colonne %s n'est pas dans la table %s";                                    break;
    case MSG_COL_NOT_SORTED:  p = "La colonne %s de la table %s n'est pas triée";                                break;
    case MSG_COL_NUM_MISM:    p = "Disparité du nombre de colonnes";                                             break;
    case MSG_COM_ERROR:       p = "Erreur Com";                                                                  break;
    case MSG_CONCAT_SUBNODE:  p = "Concaténation de sous-noeuds impossible";                                     break;
    case MSG_CONNECT_CANCEL:  p = "Connection interrompue par l'utilisateur";                                    break;
    case MSG_CONTROL_C_EXIT:  p = "Exit par Ctrl-C";                                                             break;
    case MSG_DATABASE_LOADED: p = "Base de données %s chargée";                                                  break;
    case MSG_DATA_MISALIGN:   p = "Mauvais alignement pour ce type de données";                                  break;
    case MSG_DBASE_FILE:      p = "Fichier dBASE dbf: ";                                                         break;
    case MSG_DEF_ALLOC_ERROR: p = "Erreur d'allocation de la classe DEF %s";                                     break;
    case MSG_DEL_FILE_ERR:    p = "Erreur à l'effacement de %s";                                                 break;
    case MSG_DEL_READ_ERROR:  p = "Delete: erreur en lecture req=%d len=%d";                                     break;
    case MSG_DEL_WRITE_ERROR: p = "Delete: erreur en écriture: %s";                                              break;
    case MSG_DEPREC_FLAG:     p = "Option Flag périmée, utiliser Coltype";                                       break;
    case MSG_DLL_LOAD_ERROR:  p = "Erreur %d au chargement du module %s";                                        break;
    case MSG_DOM_NOT_SUPP:    p = "MS-DOM non supporté par cette version";                                       break;
    case MSG_DVAL_NOTIN_LIST: p = "Valeur %s non trouvée dans la liste des valeurs distinctes de la colonne %s"; break;
    case MSG_EMPTY_DOC:       p = "Document vide";                                                               break;
    case MSG_EMPTY_FILE:      p = "%s du fichier vide %s: ";                                                     break;
    case MSG_EOF_AFTER_LINE:  p = "Fin de fichier après la ligne %d";                                            break;
    case MSG_EOF_INDEX_FILE:  p = "EOF lisant le fichier index";                                                 break;
    case MSG_ERROR_IN_LSK:    p = "Erreur %d dans lseek64";                                                      break;
    case MSG_ERROR_IN_SFP:    p = "Erreur %d dans SetFilePointer";                                               break;
    case MSG_ERR_READING_REC: p = "Erreur lisant l'enregistrement %d de %s";                                     break;
    case MSG_FAIL_ADD_NODE:   p = "L'ajout du noeud %s dans la table a échoué";                                  break;
    case MSG_FETCH_NO_RES:    p = "Fetch: Pas de Résultats";                                                     break;
    case MSG_FIELD_TOO_LONG:  p = "Valeur trop longue pour le champs %d ligne %d";                               break;
    case MSG_FILELEN_ERROR:   p = "Erreur dans %s pour %s";                                                      break;
    case MSG_FILE_IS_EMPTY:   p = "Le fichier %s est vide";                                                      break;
    case MSG_FILE_MAP_ERR:    p = "Erreur de File mapping";                                                      break;
    case MSG_FILE_MAP_ERROR:  p = "CreateFileMapping %s erreur rc=%d";                                           break;
    case MSG_FILE_OPEN_YET:   p = "Fichier %s déjà ouvert";                                                      break;
    case MSG_FILE_UNFOUND:    p = "Fichier %s non trouvé";                                                       break;
    case MSG_FLD_TOO_LNG_FOR: p = "Champs %d trop long pour %s ligne %d de %s";                                  break;
    case MSG_FLT_BAD_RESULT:  p = "Virgule flottante: résultat inexacte";                                        break;
    case MSG_FLT_DENORMAL_OP: p = "Opérande virgule flottante non normalisé";                                    break;
    case MSG_FLT_INVALID_OP:  p = "Opération virgule flottante invalide";                                        break;
    case MSG_FLT_OVERFLOW:    p = "Dépassement de capacité virgule flottante";                                   break;
    case MSG_FLT_STACK_CHECK: p = "Virgule flottante: Erreur de la pile";                                        break;
    case MSG_FLT_UNDERFLOW:   p = "Sous-dépassement de capacité virgule flottante";                              break;
    case MSG_FLT_ZERO_DIVIDE: p = "Virgule flottante: division par zéro";                                        break;
    case MSG_FMT_WRITE_NIY:   p = "L'écriture des fichiers %s n'est pas encore implémentée";                     break;
    case MSG_FOXPRO_FILE:     p = "Fichier FoxPro: ";                                                            break;
    case MSG_FPUTS_ERROR:     p = "Erreur dans fputs: %s";                                                       break;
    case MSG_FSEEK_ERROR:     p = "Erreur dans fseek: %s";                                                       break;
    case MSG_FSETPOS_ERROR:   p = "Erreur dans fseek pour i=%d";                                                 break;
    case MSG_FTELL_ERROR:     p = "Erreur dans ftell enregistrement=%d: %s";                                     break;
    case MSG_FUNCTION_ERROR:  p = "Erreur dans %s: %d";                                                          break;
    case MSG_FUNC_ERRNO:      p = "Erreur %d dans %s";                                                           break;
    case MSG_FUNC_ERROR:      p = "Erreur dans %s";                                                              break;
    case MSG_FUNC_ERR_S:      p = "Erreur dans %s: %s";                                                          break;
    case MSG_FWRITE_ERROR:    p = "Erreur dans fwrite: %s";                                                      break;
    case MSG_GET_DIST_VALS:   p = "Récupération des valeurs distinctes de ";                                     break;
    case MSG_GET_FUNC_ERR:    p = "Erreur en recherche de la fonction %s: %s";                                   break;
    case MSG_GLOBAL_ERROR:    p = "Erreur d'allocation de Global (taille=%d)\n";                                 break;
    case MSG_GUARD_PAGE:      p = "Violation de page de garde";                                                  break;
    case MSG_GZOPEN_ERROR:    p = "gzopen %s: erreur %d sur %s";                                                 break;
    case MSG_ILLEGAL_INSTR:   p = "Instruction illégale";                                                        break;
    case MSG_ILL_FILTER_CONV: p = "Conversion implicite illégale dans un filtre";                                break;
    case MSG_INDEX_NOT_UNIQ:  p = "L'index n'est pas Unique";                                                    break;
    case MSG_INDEX_YET_ON:    p = "L'index %s existe déjà sur %s";                                               break;
    case MSG_INDX_COL_NOTIN:  p = "La colonne index %s n'existe pas dans la table %s";                           break;
    case MSG_INDX_EXIST_YET:  p = "L'entrée index existe déjà";                                                  break;
    case MSG_INIT_FAILED:     p = "L'initialisation de %s a échoué";                                             break;
    case MSG_INT_COL_ERROR:   p = "Erreur interne sur la colonne index %s";                                      break;
    case MSG_INT_OVERFLOW:    p = "Dépassement de capacité sur entier";                                          break;
    case MSG_INT_ZERO_DIVIDE: p = "Division entière par zéro";                                                   break;
    case MSG_INVALID_DISP:    p = "Disposition invalide";                                                        break;
    case MSG_INVALID_FTYPE:   p = "SBV: Ftype %d invalide";                                                      break;
    case MSG_INVALID_HANDLE:  p = "Poignée invalide";                                                            break;
    case MSG_INVALID_OPER:    p = "Opérateur invalide %d pour %s";                                               break;
    case MSG_INV_COLUMN_TYPE: p = "Type %d Invalide pour la colonne %s";                                         break;
    case MSG_INV_COL_TYPE:    p = "Type de colonne %s invalide";                                                 break;
    case MSG_INV_DEF_READ:    p = "Lecture différée invalide rc=%d";                                             break;
    case MSG_INV_DIRCOL_OFST: p = "Offset invalide pour une colonne DIR";                                        break;
    case MSG_INV_MAP_POS:     p = "Position mémoire invalide";                                                   break;
    case MSG_INV_RAND_ACC:    p = "L'accès aléatoire d'une table non optimisée est impossible";                  break;
    case MSG_INV_REC_POS:     p = "Position d'enregistrement invalide";                                          break;
    case MSG_INV_RESULT_TYPE: p = "Type de résultat invalide %s";                                                break;
    case MSG_INV_UPDT_TABLE:  p = "Table %s invalide pour Update";                                               break;
    case MSG_IN_WITHOUT_SUB:  p = "IN ou EXISTS sans tableau ou subquery";                                       break;
    case MSG_KEY_ALLOC_ERR:   p = "Erreur d'allocation d'un bloc offset clé";                                    break;
    case MSG_KEY_ALLOC_ERROR: p = "Erreur d'allocation mémoire, Klen=%d n=%d";                                   break;
    case MSG_LINE_TOO_LONG:   p = "La nouvelle ligne est trop longue";                                           break;
    case MSG_LIST:            p = "--Liste--";                                                                   break;
    case MSG_LOADING_FAILED:  p = "Le chargement de %s a échoué";                                                break;
    case MSG_LRECL_TOO_SMALL: p = "Lrecl trop petit (longueur en-tête = %d)";                                    break;
    case MSG_MAKE_EMPTY_FILE: p = "Génération du fichier vide %s: %s";                                           break;
    case MSG_MAKING:          p = "Génération";                                                                  break;
    case MSG_MALLOC_ERROR:    p = "Allocation mémoire impossible par %s";                                        break;
    case MSG_MAP_VIEW_ERROR:  p = "MapViewOfFile %s erreur rc=%d";                                               break;
    case MSG_MAXSIZE_ERROR:   p = "Maxsize incalculable sur table ouverte";                                      break;
    case MSG_MEM_ALLOC_ERR:   p = "Erreur d'allocation mémoire, taille %s = %d";                                 break;
    case MSG_MEM_ALLOC_ERROR: p = "Erreur d'allocation mémoire";                                                 break;
    case MSG_MISPLACED_QUOTE: p = "Appostrophe mal placée ligne %d";                                             break;
    case MSG_MISSING_ARG:     p = "Argument manquant pour l'opérateur %d";                                       break;
    case MSG_MISSING_FIELD:   p = "Champs %d manquant dans %s ligne %d";                                         break;
    case MSG_MISSING_FNAME:   p = "Nom du fichier manquant";                                                     break;
    case MSG_MISSING_NODE:    p = "Noeud %s manquant dans %s";                                                   break;
    case MSG_MISSING_ROWNODE: p = "Impossible de trouver le noeud de la ligne %d";                               break;
    case MSG_MIS_TAG_LIST:    p = "Liste des balises colonne manquante";                                         break;
    case MSG_MUL_MAKECOL_ERR: p = "Erreur logique dans TABMUL::MakeCol";                                         break;
    case MSG_NAME_CONV_ERR:   p = "Erreur de convertion du nom de noeud";                                        break;
    case MSG_NEW_DOC_FAILED:  p = "Impossible de créer le nouveau document";                                     break;
    case MSG_NEW_RETURN_NULL: p = "NULL renvoyé par New dans PlugEvalLike";                                      break;
    case MSG_NEXT_FILE_ERROR: p = "Erreur en recherche du fichier suivant. rc=%s";                               break;
    case MSG_NONCONT_EXCEPT:  p = "Exception non-continuable";                                                   break;
    case MSG_NOP_ZLIB_INDEX:  p = "L'indexage d'une table zlib non optimisée est impossible";                    break;
    case MSG_NOT_A_DBF_FILE:  p = "Le fichier n'a pas le format dBASE dbf ";                                     break;
    case MSG_NOT_FIXED_LEN:   p = "Fichier %s non fixe, len=%d lrecl=%d";                                        break;
    case MSG_NO_0DH_HEAD:     p = "0DH manquant en fin d'en-tête (dbc=%d)";                                      break;
    case MSG_NO_ACTIVE_DB:    p = "Pas de base de données active";                                               break;
    case MSG_NO_CHAR_FROM:    p = "Conversion de type %d en caractères impossible";                              break;
    case MSG_NO_DATE_FMT:     p = "Pas de format date pour le valblock de type %d";                              break;
    case MSG_NO_DEF_FNCCOL:   p = "Colonne fonction par défaut introuvable";                                     break;
    case MSG_NO_DEF_PIVOTCOL: p = "Colonne pivot par défaut introuvable";                                        break;
    case MSG_NO_DIR_INDX_RD:  p = "Pas d'accès directe des tables %s";                                           break;
    case MSG_NO_FEAT_SUPPORT: p = "%s non supporté dans cette version";                                          break;
    case MSG_NO_FLD_FORMAT:   p = "Format absent pour le champs %d de %s";                                       break;
    case MSG_NO_FORMAT_COL:   p = "Type COLUMN informattable";                                                   break;
    case MSG_NO_FORMAT_TYPE:  p = "Le format ne peut pas être défini à partir du type %d";                       break;
    case MSG_NO_INDEX_READ:   p = "Pas d'accès directe des tables multiples";                                    break;
    case MSG_NO_KEY_COL:      p = "Pas de colonne clé trouvée";                                                  break;
    case MSG_NO_KEY_UPDATE:   p = "Le nom des clés ne peut pas être modifié";                                    break;
    case MSG_NO_MAP_INSERT:   p = "MAP incompatible avec Insert";                                                break;
    case MSG_NO_MATCHING_COL: p = "Pas de colonne correspondant à %s dans %s";                                   break;
    case MSG_NO_MATCH_COL:    p = "Colonne correspondante introuvable";                                          break;
    case MSG_NO_MEMORY:       p = "Mémoire pleine";                                                              break;
    case MSG_NO_MODE_PADDED:  p = "Mode non supporté pour les fichiers 'padded'";                                break;
    case MSG_NO_MUL_VCT:      p = "Les tables VCT ne peuvent pas être multiples";                                break;
    case MSG_NO_ODBC_DELETE:  p = "Delete ne devrait pas être appelé pour les tables ODBC";                      break;
    case MSG_NO_ODBC_DIRECT:  p = "Accès directe des tables ODBC non encore implémenté";                         break;
    case MSG_NO_ODBC_MUL:     p = "Multiple(2) non supporté pour les tables ODBC";                               break;
    case MSG_NO_ODBC_SPECOL:  p = "Pas de colonne spéciale ODBC";                                                break;
    case MSG_NO_PART_DEL:     p = "Delete partiel des fichier %s impossible";                                    break;
    case MSG_NO_PART_MAP:     p = "Mapping partiel non implémenté pour cet OS";                                  break;
    case MSG_NO_PAR_BLK_INS:  p = "Insertion de bloc partiel impossible";                                        break;
    case MSG_NO_PIV_DIR_ACC:  p = "Pas d'accès directe aux tables PIVOT";                                        break;
    case MSG_NO_READ_32:      p = "Lecture de 32 octets impossible";                                             break;
    case MSG_NO_RECOV_SPACE:  p = "Espace non recouvrable dans le fichier index";                                break;
    case MSG_NO_ROWID_FOR_AM: p = "Accès direct impossible de ROWID pour les tables de type %s";                 break;
    case MSG_NO_ROW_NODE:     p = "Le nom du Rownode n'est pas défini";                                          break;
    case MSG_NO_SECTION_NAME: p = "Nom de section manquant";                                                     break;
    case MSG_NO_SEC_UPDATE:   p = "Les noms de section ne peuvent pas être modifiés";                            break;
    case MSG_NO_SETPOS_YET:   p = "SetPos pas encore implémenté pour les fichier %s";                            break;
    case MSG_NO_SPEC_COL:     p = "Pas de colonne spéciales MYSQL";                                              break;
    case MSG_NO_SUB_VAL:      p = "Pas de sous-value d'un tableau de type %d";                                   break;
    case MSG_NO_TABCOL_DATA:  p = "Pas de données pour la table %s colonne %s";                                  break;
    case MSG_NO_TABLE_DEL:    p = "Delete non autorisé pour les tables %s   ";                                   break;
    case MSG_NO_TAB_DATA:     p = "Pas de données pour la table %s";                                             break;
    case MSG_NO_VCT_DELETE:   p = "Délétion Partielle non implémentée pour les fichiers VCT";                    break;
    case MSG_NO_ZIP_DELETE:   p = "Delete sur fichier Zip non encore implementé";                                break;
    case MSG_OPENING:         p = "Ouverture";                                                                   break;
    case MSG_OPEN_EMPTY_FILE: p = "Ouverture du fichier vide %s: %s";                                            break;
    case MSG_OPEN_ERROR:      p = "Erreur d'ouverture %d en mode %d sur %s: ";                                   break;
    case MSG_OPEN_ERROR_IS:   p = "Erreur à l'ouverture de %s: %s";                                              break;
    case MSG_OPEN_MODE_ERROR: p = "Erreur d'ouverture(%s) %d sur %s";                                            break;
    case MSG_OPEN_STRERROR:   p = "Erreur à l'ouverture: %s";                                                    break;
    case MSG_OPTBLK_RD_ERR:   p = "Erreur à la lecture d'un bloc optimisation: %s";                              break;
    case MSG_OPTBLK_WR_ERR:   p = "Erreur à l'écriture d'un bloc optimisation: %s";                              break;
    case MSG_OPTIMIZING:      p = "Optimisation de ";                                                            break;
    case MSG_OPT_BMAP_RD_ERR: p = "Erreur en lecture des bitmaps d'optimisation: %s";                            break;
    case MSG_OPT_BMAP_WR_ERR: p = "Erreur en écriture des bitmaps d'optimisation: %s";                           break;
    case MSG_OPT_CANCELLED:   p = "Optimisation interrompue par l'utilisateur";                                  break;
    case MSG_OPT_DVAL_RD_ERR: p = "Erreur en lecture des valeurs distinctes: %s";                                break;
    case MSG_OPT_DVAL_WR_ERR: p = "Erreur en écriture des valeurs distinctes: %s";                               break;
    case MSG_OPT_HEAD_RD_ERR: p = "Erreur en lecture de l'entête du fichier opt: %s";                            break;
    case MSG_OPT_HEAD_WR_ERR: p = "Erreur en écriture de l'entête du fichier opt: %s";                           break;
    case MSG_OPT_LOGIC_ERR:   p = "Erreur logique dans SetBitmap, i=%d";                                         break;
    case MSG_OPT_MAX_RD_ERR:  p = "Erreur en lecture des valeurs maxi: %s";                                      break;
    case MSG_OPT_MAX_WR_ERR:  p = "Erreur en écriture des valeurs maxi: %s";                                     break;
    case MSG_OPT_MIN_RD_ERR:  p = "Erreur en lecture des valeurs mini: %s";                                      break;
    case MSG_OPT_MIN_WR_ERR:  p = "Erreur en écriture des valeurs mini: %s";                                     break;
    case MSG_OPT_NOT_MATCH:   p = "Le fichier opt %s n'est pas à jour";                                          break;
    case MSG_PAGE_ERROR:      p = "Erreur de pagination";                                                        break;
    case MSG_PARM_CNT_MISS:   p = "Disparité du nombre de Paramètres";                                           break;
    case MSG_PREC_VBLP_NULL:  p = "ARRAY SetPrecision: Vblp est NULL";                                           break;
    case MSG_PRIV_INSTR:      p = "Instruction privilégiée";                                                     break;
    case MSG_PROCADD_ERROR:   p = "Erreur %d sur l'adresse de %s";                                               break;
    case MSG_QUERY_CANCELLED: p = "Requête interrompue par l'utilisateur";                                       break;
    case MSG_RANGE_NO_JOIN:   p = "Range non compatible avec les index de jointure";                             break;
    case MSG_RC_READING:      p = "rc=%d en lecture de la table %s";                                             break;
    case MSG_READY:           p = "Prêt";                                                                        break;
    case MSG_READ_ERROR:      p = "Erreur en lecture sur %s: %s";                                                break;
    case MSG_READ_ONLY:       p = "Cette table protégée en lecture seule ne peut être modifiée";                 break;
    case MSG_READ_SEEK_ERROR: p = "Erreur de recherche en lecture: %s";                                          break;
    case MSG_REGISTER_ERR:    p = "Enregistrement NS impossible, préfix='%s' et href='%s'";                      break;
    case MSG_REMOVE_ERROR:    p = "Erreur en supprimant %s: %s";                                                 break;
    case MSG_RENAME_ERROR:    p = "Erreur renommant %s en %s: %s";                                               break;
    case MSG_ROWID_NOT_IMPL:  p = "RowNumber non implémenté pour les tables de type %s";                         break;
    case MSG_SEC_KEY_FIRST:   p = "Les sections et clés doivent être insérées en premier";                       break;
    case MSG_SEC_NAME_FIRST:  p = "Le nom de section doit être en tête de liste en insertion";                   break;
    case MSG_SEP_IN_FIELD:    p = "Le champ %d contient le caractère séparateur";                                break;
    case MSG_SEQUENCE_ERROR:  p = "HSTMT: Allocation hors séquence";                                             break;
    case MSG_SETEOF_ERROR:    p = "Erreur %d dans SetEndOfFile";                                                 break;
    case MSG_SETRECPOS_NIY:   p = "SetRecpos non implémenté pour ce type de table";                              break;
    case MSG_SET_STR_TRUNC:   p = "SetValue: Chaîne de caractères tronquée";                                     break;
    case MSG_SFP_ERROR:       p = "Erreur sur SetFilePointer: %s";                                               break;
    case MSG_SHARED_LIB_ERR:  p = "Erreur au chargement de la librairie partagée %s: %s";                        break;
    case MSG_SINGLE_STEP:     p = "Pas à pas";                                                                   break;
    case MSG_SORTING_VAL:     p = "Tri de %d valeurs";                                                           break;
    case MSG_SPCOL_READONLY:  p = "La colonne spéciale %s est en lecture seulement";                             break;
    case MSG_SQL_CONF_ERROR:  p = "Erreur SQL: SQL_CONFORMANCE";                                                 break;
    case MSG_SRCH_CLOSE_ERR:  p = "Erreur à la fermeture de l'Handle de recherche";                              break;
    case MSG_SRC_TABLE_UNDEF: p = "La table source n'est pas définie";                                           break;
    case MSG_STACK_OVERFLOW:  p = "Dépassement de capacité de la pile";                                          break;
    case MSG_TABDIR_READONLY: p = "Les tables DIR sont en lecture seulement";                                    break;
    case MSG_TABLE_NOT_OPT:   p = "Table non optimisable";                                                       break;
    case MSG_TABLE_NO_INDEX:  p = "La table %s n'est pas indexable";                                             break;
    case MSG_TABLE_READ_ONLY: p = "Les tables %s sont en lecture seulement   ";                                  break;
    case MSG_TABMUL_READONLY: p = "Les tables multiples sont en lecture seulement";                              break;
    case MSG_TOO_MANY_FIELDS: p = "Trop de champs ligne %d de %s";                                               break;
    case MSG_TOO_MANY_JUMPS:  p = "Trop de niveaux de saut";                                                     break;
    case MSG_TOO_MANY_KEYS:   p = "Trop de clés (%d)";                                                           break;
    case MSG_TO_BLK_IS_NULL:  p = "To Blk est nul";                                                              break;
    case MSG_TRUNCATE_ERROR:  p = "Erreur en troncation: %s";                                                    break;
    case MSG_TRUNC_BY_ESTIM:  p = "Tronqué par l'option Estimate";                                               break;
    case MSG_TYPE_MISMATCH:   p = "Clé et source ne sont pas du même type";                                      break;
    case MSG_TYPE_VALUE_ERR:  p = "Colonne %s: disparité type(%s)/valeur(%s)";                                   break;
    case MSG_UNBALANCE_QUOTE: p = "Appostrophe en trop ligne %d";                                                break;
    case MSG_UNDEFINED_AM:    p = "COLBLK %s: méthode d'accès indéfinie";                                        break;
    case MSG_UNKNOWN_EXCPT:   p = "Exception non répertoriée";                                                   break;
    case MSG_UNMATCH_FIL_ARG: p = "Argument de filtre dépareillé";                                               break;
    case MSG_UPDATE_ERROR:    p = "Erreur en Update sur %s";                                                     break;
    case MSG_UPD_ZIP_NOT_IMP: p = "Mise à jour des tables ZDOS non encore implementé";                           break;
    case MSG_VALSTR_TOO_LONG: p = "Valeur %s trop longue pour une chaîne de longueur %d";                        break;
    case MSG_VALTYPE_NOMATCH: p = "Disparité types de valeur";                                                   break;
    case MSG_VALUE_ERROR:     p = "Colonne %s: bloc valeur nul";                                                 break;
    case MSG_VALUE_TOO_BIG:   p = "Valeur %lld trop grande pour la colonne %s";                                  break;
    case MSG_VALUE_TOO_LONG:  p = "Valeur %s trop longue pour la colonne %s de longueur %d";                     break;
    case MSG_VAL_ALLOC_ERR:   p = "Allocation impossible du noeud valeur";                                       break;
    case MSG_VIR_NO_DELETE:   p = "Delete impossible sur les tables %s";                                         break;
    case MSG_VIR_READ_ONLY:   p = "Les tables virtuelles %s sont en lecture seulement";                          break;
    case MSG_VOID_FIRST_ARG:  p = "Le premier argument ne doit pas être vide";                                   break;
    case MSG_WORK_AREA:       p = "Espace de travail: %s";                                                       break;
    case MSG_WRITE_SEEK_ERR:  p = "Erreur de recherche en écriture: %s";                                         break;
    case MSG_WRITE_STRERROR:  p = "Erreur en écriture sur %s: %s";                                               break;
    case MSG_WRITING:         p = "Ecriture";                                                                    break;
    case MSG_WRITING_ERROR:   p = "Erreur à l'écriture de %s: %s";                                               break;
    case MSG_WS_CONV_ERR:     p = "Erreur de convertion de %s en WS";                                            break;
    case MSG_XCOL_MISMATCH:   p = "La colonne %s ne correspond pas à l'index";                                   break;
    case MSG_XFILE_READERR:   p = "Erreur %d en lisant le fichier index";                                        break;
    case MSG_XFILE_WRITERR:   p = "Erreur en écrivant le fichier index: %s";                                     break;
    case MSG_XMLTAB_INIT_ERR: p = "Erreur d'initialisation de la table XML";                                     break;
    case MSG_XML_INIT_ERROR:  p = "Erreur d'initialisation du nouveau fichier XML";                              break;
    case MSG_XPATH_CNTX_ERR:  p = "Le nouveau contexte XPath ne peut être créé";                                 break;
    case MSG_XPATH_EVAL_ERR:  p = "Impossible d'évaluer l'emplacement xpath '%s'";                               break;
    case MSG_XPATH_NOT_SUPP:  p = "Xpath non supporté colonne %s";                                               break;

diff --git a/elf/Makefile b/elf/Makefile
index 8a3f5b7905514c291d..f9c7fd148a4ee6a7f0 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -310,7 +310,7 @@ $(objpfx)ld.so: $(objpfx)librtld.os $(ld-map)
 		  $(LDFLAGS-rtld) -Wl,-z,defs -Wl,--verbose 2>&1 |	\
 		  LC_ALL=C \
 		  sed -e '/^=========/,/^=========/!d;/^=========/d'	\
-		      -e 's/\. = 0 + SIZEOF_HEADERS;/& _begin = . - SIZEOF_HEADERS;/' \
+		      -e 's/\. = .* + SIZEOF_HEADERS;/& _begin = . - SIZEOF_HEADERS;/' \
 		  > $@.lds
 	$(LINK.o) -nostdlib -nostartfiles -shared -o $@			\
 		  $(LDFLAGS-rtld) -Wl,-z,defs $(z-now-$(bind-now))	\
@@ -327,7 +327,7 @@ $(objpfx)ld.so: $(objpfx)librtld.os $(ld-map)
 # TODO(mseaborn): Remove the need to have two versions of ld.so.
 $(objpfx)runnable-ld.so: $(objpfx)ld.so nacl_fixup_ldso.py
 	cp $(objpfx)ld.so $@.tmp
-	python nacl_fixup_ldso.py $@.tmp
+	python2 nacl_fixup_ldso.py $@.tmp
 	mv -f $@.tmp $@
 
 # interp.c exists just to get this string into the libraries.
diff --git a/elf/nacl_fixup_ldso.py b/elf/nacl_fixup_ldso.py
index f60becc06562b538cd..2aaab30380b7067caf 100644
--- a/elf/nacl_fixup_ldso.py
+++ b/elf/nacl_fixup_ldso.py
@@ -27,7 +27,7 @@ def main(args):
         raise Exception("Usage: fixup <filename>")
     filename = args[0]
     fh = open(filename, "r+")
-    
+
     def check(ty, offset, expected):
         fh.seek(offset)
         data = fh.read(struct.calcsize(ty))
@@ -39,22 +39,29 @@ def main(args):
         fh.seek(offset)
         fh.write(struct.pack(ty, value))
 
-    # sel_ldr only accepts ELF objects with e_type=ET_EXEC.
-    check("B", offset_e_type, ET_DYN)
-    replace("B", offset_e_type, ET_EXEC)
+    try:
+        # sel_ldr only accepts ELF objects with e_type=ET_EXEC.
+        check("B", offset_e_type, ET_DYN)
+        replace("B", offset_e_type, ET_EXEC)
+    except AssertionError as e:
+        print(e)
 
-    # sel_ldr rejects ELF Program Headers other than PT_LOAD.
-    # Drop PT_DYNAMIC, PT_GNU_STACK and PT_TLS.
-    fh.seek(offset_ei_class)
-    elfclass = fh.read(1)
-    if elfclass == elfclass32:
-        check("H", offset_e_phnum32, 6)
-        replace("H", offset_e_phnum32, 3)
-    elif elfclass == elfclass64:
-        check("H", offset_e_phnum64, 6)
-        replace("H", offset_e_phnum64, 3)
-    else:
-        raise AssertionError("Unknown ELF class in file %s." % filename)
+    try:
+        # sel_ldr rejects ELF Program Headers other than PT_LOAD.
+        # Drop PT_DYNAMIC, PT_GNU_STACK and PT_TLS.
+        fh.seek(offset_ei_class)
+        elfclass = fh.read(1)
+        if elfclass == elfclass32:
+            check("H", offset_e_phnum32, 9)
+            replace("H", offset_e_phnum32, 3)
+        elif elfclass == elfclass64:
+            check("H", offset_e_phnum64, 9)
+            replace("H", offset_e_phnum64, 3)
+        else:
+            raise AssertionError("Unknown ELF class in file %s." % filename)
+
+    except AssertionError as e:
+        print(e)
 
     fh.close()
 
diff --git a/manual/Makefile b/manual/Makefile
index c5866eb9def3becfc6..f82c9efe188540e8df 100644
--- a/manual/Makefile
+++ b/manual/Makefile
@@ -232,7 +232,8 @@ ifdef objpfx
 .PHONY: stubs
 stubs: $(objpfx)stubs
 endif
-$(objpfx)stubs ../po/manual.pot $(objpfx)stamp%:
+stamps := $(foreach o,$(object-suffixes-for-libc),$(objpfx)stamp$o)
+$(objpfx)stubs ../po/manual.pot $(objpfx)stamp.o $(stamps):
 	$(make-target-directory)
 	touch $@
 
@@ -245,7 +246,7 @@ endef
 
 # The top-level glibc Makefile expects subdir_install to update the stubs file.
 subdir_install: stubs
-
+
 # Get rid of these variables if they came from the parent.
 routines =
 aux =
